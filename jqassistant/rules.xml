<jqa:jqassistant-rules xmlns:jqa="http://www.buschmais.com/jqassistant/core/analysis/rules/schema/v1.0">

    <constraint id="my-rules:TestClassName">
        <requiresConcept refId="junit4:TestClass" />
        <description>All JUnit test classes must have a name with suffix "Test".</description>
        <cypher><![CDATA[
            MATCH
                (t:Junit4:Test:Class)
            WHERE NOT
                t.name =~ ".*Test"
            RETURN
                t AS InvalidTestClass
        ]]></cypher>
    </constraint>

    <constraint id="test:TestCoverageForLowComplexity">
        <description>...</description>
        <cypher><![CDATA[
        match (cl:JacocoClass)--(m:JacocoMethod)--(c:JacocoCounter {type: 'COMPLEXITY'})
        where c.missed+c.covered >= 2 and c.missed+c.covered <= 3 and not(m.signature ='boolean equals(java.lang.Object)') and not(m.signature ='int hashCode()')
        with m as method, cl.fqn as fqn, m.signature as signature, c.missed+c.covered as complexity
        match (m)--(branches:JacocoCounter {type: 'BRANCH'})
        where m=method and branches.covered*100/(branches.covered+branches.missed) < 0
        return fqn, signature, complexity, branches.covered*100/(branches.covered+branches.missed) as coverage
        ]]></cypher>
    </constraint>

    <constraint id="test:TestCoverageForMediumComplexity">
        <description>...</description>
        <cypher><![CDATA[
        match (cl:JacocoClass)--(m:JacocoMethod)--(c:JacocoCounter {type: 'COMPLEXITY'})
        where c.missed+c.covered >= 4 and c.missed+c.covered <= 5 and not(m.signature ='boolean equals(java.lang.Object)') and not(m.signature ='int hashCode()')
        with m as method, cl.fqn as fqn, m.signature as signature, c.missed+c.covered as complexity
        match (m)--(branches:JacocoCounter {type: 'BRANCH'})
        where m=method and branches.covered*100/(branches.covered+branches.missed) < 80
        return fqn, signature, complexity, branches.covered*100/(branches.covered+branches.missed) as coverage
        ]]></cypher>
    </constraint>

    <constraint id="test:TestCoverageForHighComplexity">
        <description>...</description>
        <cypher><![CDATA[
        MATCH (cl:JacocoClass)--(m:JacocoMethod)--(c:JacocoCounter {type: 'COMPLEXITY'})
        WHERE c.missed+c.covered > 50 AND NOT(m.signature ='boolean equals(java.lang.Object)') AND NOT(m.signature ='int hashCode()')
        WITH m AS method, cl.fqn AS fqn, m.signature AS signature, c.missed+c.covered AS complexity
        MATCH (m)--(branches:JacocoCounter {type: 'BRANCH'})
        WHERE m=method AND branches.covered*100/(branches.covered+branches.missed) < 90
        RETURN fqn, signature, complexity, branches.covered*100/(branches.covered+branches.missed) AS coverage
        ]]></cypher>
    </constraint>

    <concept id="jacoco:TestCoverageMediumRange">
        <description>Define ranges for test coverage.</description>
        <cypher><![CDATA[
        CREATE
            (n:TestCoverageRange {min : 40, max : 49, coverage : 80 })
        RETURN
            n
    ]]></cypher>
    </concept>

    <concept id="jacoco:TestCoverageHighRange">
        <description>Define ranges for test coverage.</description>
        <cypher><![CDATA[
        CREATE
            (n:TestCoverageRange { min : 50, max : 999999, coverage : 90 })
        RETURN
            n
    ]]></cypher>
    </concept>


    <constraint id="test:TestCoverageForConfiguredComplexity">
        <requiresConcept refId="jacoco:TestCoverageMediumRange"/>
        <requiresConcept refId="jacoco:TestCoverageHighRange"/>
        <description>...</description>
        <cypher><![CDATA[
        MATCH (tcr:TestCoverageRange)
        WITH tcr.min AS mincomplexity, tcr.max as maxcomplexity, tcr.coverage AS coveragethreshold
        MATCH (cl:JacocoClass)--(m:JacocoMethod)--(c:JacocoCounter {type: 'COMPLEXITY'})
        WHERE c.missed+c.covered >= mincomplexity AND c.missed+c.covered <= maxcomplexity
        AND NOT(m.signature ='boolean equals(java.lang.Object)') AND NOT(m.signature ='int hashCode()')
        AND NOT(cl.fqn =~ 'net.sourceforge.plantuml.sudoku.dlx_solver.*')
        WITH m AS method, cl.fqn AS fqn, m.signature AS signature, c.missed+c.covered AS complexity, coveragethreshold as coveragethreshold
        MATCH (m)--(branches:JacocoCounter {type: 'BRANCH'})
        WHERE m=method AND branches.covered*100/(branches.covered+branches.missed) < coveragethreshold
        RETURN complexity, coveragethreshold, branches.covered*100/(branches.covered+branches.missed) AS coverage, fqn, signature
        ORDER BY complexity, coverage
        ]]></cypher>
    </constraint>


    <group id="default">
        <includeConstraint refId="my-rules:TestClassName" />
<!--
        <includeConstraint refId="test:TestCoverageForLowComplexity" />
        <includeConstraint refId="test:TestCoverageForMediumComplexity" />
        <includeConstraint refId="test:TestCoverageForHighComplexity" />
-->
        <includeConstraint refId="test:TestCoverageForConfiguredComplexity" />
    </group>

</jqa:jqassistant-rules>
